import { BUN_TRAILER, BUN_VERSION_MATCH, BUNFS_ROOT, BUNFS_ROOT_OLD } from "./constants";

export interface BundledFile {
  path: string;
  contents: ArrayBuffer;
}

const corruptionMessage =
  ". Either the binary is corrupted or it's not an executable file generated by `bun build --compile`.";

export class InvalidExecutableError extends Error {
  constructor(msg = "Invalid executable") {
    super(msg + corruptionMessage);
    this.name = "InvalidExecutableError";
  }
}

export class InvalidTrailerError extends InvalidExecutableError {
  constructor() {
    super("Invalid executable trailer");
    this.name = "InvalidTrailerError";
  }
}

export class TotalByteCountMismatchError extends InvalidExecutableError {
  constructor() {
    super("Executable byte count mismatch");
    this.name = "TotalByteCountMismatchError";
  }
}

export interface ExtractBundledFilesOptions {
  removeBunfsRoot?: boolean;
  removeLeadingSlash?: boolean;
}

export function extractBundledFiles(
  compiledBinaryData: DataView | ArrayBuffer,
  options: ExtractBundledFilesOptions = {},
) {
  options = {
    removeBunfsRoot: true,
    removeLeadingSlash: true,
    ...options,
  };

  if (!options.removeBunfsRoot && options.removeLeadingSlash) {
    throw new Error(
      "Cannot remove leading slash without removing Bun-fs root from bundled file paths",
    );
  }

  if (compiledBinaryData instanceof ArrayBuffer) {
    compiledBinaryData = new DataView(compiledBinaryData);
  }

  const decoder = new TextDecoder();

  // Note: reverse engineering
  // bun/src/StandaloneModuleGraph.zig/StandaloneModuleGraph/toBytes

  // Check that the executable has the right trailer
  const trailer = decoder.decode(
    compiledBinaryData.buffer.slice(
      compiledBinaryData.byteLength - 8 - BUN_TRAILER.length,
      compiledBinaryData.byteLength - 8,
    ),
  );
  if (trailer !== BUN_TRAILER) {
    throw new InvalidTrailerError();
  }

  const totalByteCount = compiledBinaryData.getUint32(compiledBinaryData.byteLength - 8, true);
  if (compiledBinaryData.byteLength !== totalByteCount) {
    throw new TotalByteCountMismatchError();
  }

  const offsetByteCount = compiledBinaryData.getUint32(compiledBinaryData.byteLength - 48, true);

  // Not sure what this is for
  // const entrypointId = compiledBinaryData.getUint32(compiledBinaryData.byteLength - 44, true);

  const modulesPtrOffset = compiledBinaryData.getUint32(compiledBinaryData.byteLength - 40, true);

  const modulesPtrLength = compiledBinaryData.getUint32(compiledBinaryData.byteLength - 36, true);

  const modulesStart = compiledBinaryData.byteLength - (offsetByteCount + 48);
  const modulesEnd = modulesStart + modulesPtrOffset;
  const modulesData = compiledBinaryData.buffer.slice(modulesStart, modulesEnd);

  const modulesMetadataStart = modulesEnd;

  const bundledFiles: BundledFile[] = [];
  let currentOffset = 0;
  for (let i = 0; i < modulesPtrLength / 32; i++) {
    const modulesMetadataOffset = modulesMetadataStart + i * 32;
    const pathLength = compiledBinaryData.getUint32(modulesMetadataOffset + 4, true);
    const contentsLength = compiledBinaryData.getUint32(modulesMetadataOffset + 12, true);

    let path = decoder.decode(modulesData.slice(currentOffset, currentOffset + pathLength));
    if (options.removeBunfsRoot) {
      path = removeBunfsRootFromPath(path);
    }
    if (path[0] !== "/") {
      throw new InvalidExecutableError("Invalid path in bundled file in executable");
    }
    if (options.removeLeadingSlash) {
      path = path.slice(1);
    }

    const contents = modulesData.slice(
      currentOffset + pathLength,
      currentOffset + pathLength + contentsLength,
    );

    bundledFiles.push({ path, contents });

    currentOffset += pathLength + contentsLength;
  }

  return bundledFiles;
}

export function removeBunfsRootFromPath(path: string) {
  if (path.startsWith(BUNFS_ROOT)) {
    return path.slice(BUNFS_ROOT.length);
  }
  if (path.startsWith(BUNFS_ROOT_OLD)) {
    return path.slice(BUNFS_ROOT_OLD.length);
  }
  throw new Error("Path does not start with Bun-fs root");
}

export interface BunVersion {
  version: string;
  revision: string;
}

export function getExecutableVersion(data: Uint8Array | ArrayBuffer): BunVersion {
  if (data instanceof ArrayBuffer) {
    data = new Uint8Array(data);
  }

  const versionIndex = data.findIndex((_, index) => {
    for (let i = 0; i < BUN_VERSION_MATCH.length; i++) {
      if (data[index + i] !== BUN_VERSION_MATCH.charCodeAt(i)) {
        return false;
      }
    }

    return true;
  });

  if (versionIndex === -1) {
    throw new InvalidExecutableError("Could not find Bun version in executable");
  }

  const versionEndIndex = data.indexOf(27, versionIndex + BUN_VERSION_MATCH.length);

  if (versionEndIndex <= 0) {
    throw new InvalidExecutableError("Could not find Bun version end in executable");
  }

  const decoder = new TextDecoder();
  const versionString = decoder.decode(
    data.slice(versionIndex + BUN_VERSION_MATCH.length, versionEndIndex),
  );

  const [, version, revision] = versionString.match(/^(.+) \((.+)\)$/) ?? [];

  if (!version) {
    throw new InvalidExecutableError("Could not match Bun version in executable");
  }

  return {
    version,
    revision,
  };
}
