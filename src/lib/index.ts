import {
  BUN_TRAILER,
  BUN_VERSION_MATCH,
  BUN_VERSION_MATCH_OLD,
  BUNFS_ROOT,
  BUNFS_ROOT_OLD,
} from "./constants";

export interface BundledFile {
  path: string;
  contents: ArrayBuffer;
  sourcemap?: {
    version: 3;
    file: string;
    debugId?: string;
    mappings: string;
    sources: string[];
  };
}

const corruptionMessage =
  ". Either the binary is corrupted or it's not an executable file generated by `bun build --compile`.";

export class InvalidExecutableError extends Error {
  constructor(msg = "Invalid executable") {
    super(msg + corruptionMessage);
    this.name = "InvalidExecutableError";
  }
}

export class InvalidTrailerError extends InvalidExecutableError {
  constructor() {
    super("Invalid executable trailer");
    this.name = "InvalidTrailerError";
  }
}

export class TotalByteCountMismatchError extends InvalidExecutableError {
  constructor() {
    super("Executable byte count mismatch");
    this.name = "TotalByteCountMismatchError";
  }
}

export class VersionNotFoundError extends InvalidExecutableError {
  constructor() {
    super("Version not found in executable");
    this.name = "VersionNotFoundError";
  }
}

export interface ExtractBundledFilesOptions {
  normaliseEntrypointFileName?: boolean;
}

export function extractBundledFiles(
  compiledBinaryData: DataView | ArrayBuffer,
  options: ExtractBundledFilesOptions = {},
) {
  options = {
    normaliseEntrypointFileName: true,
    ...options,
  };

  if (compiledBinaryData instanceof ArrayBuffer) {
    compiledBinaryData = new DataView(compiledBinaryData);
  }

  const decoder = new TextDecoder();

  // Note: reverse engineering
  // bun/src/StandaloneModuleGraph.zig/StandaloneModuleGraph/toBytes

  // Check that the executable has the right trailer
  const trailer = decoder.decode(
    compiledBinaryData.buffer.slice(
      compiledBinaryData.byteLength - 8 - BUN_TRAILER.length,
      compiledBinaryData.byteLength - 8,
    ),
  );
  if (trailer !== BUN_TRAILER) {
    throw new InvalidTrailerError();
  }

  const totalByteCount = compiledBinaryData.getUint32(compiledBinaryData.byteLength - 8, true);
  if (compiledBinaryData.byteLength !== totalByteCount) {
    throw new TotalByteCountMismatchError();
  }

  // Helpers for reading StringPointer pairs (offset, length)
  const readPtr = (offset: number) => ({
    offset: compiledBinaryData.getUint32(offset, true),
    length: compiledBinaryData.getUint32(offset + 4, true),
  });

  const entrypointId = compiledBinaryData.getUint32(compiledBinaryData.byteLength - 44, true);

  const modulesPtr = readPtr(compiledBinaryData.byteLength - 40);

  const modulesStart = getModulesStart(compiledBinaryData);
  const modulesEnd = modulesStart + modulesPtr.offset;
  const modulesData = compiledBinaryData.buffer.slice(modulesStart, modulesEnd);

  const modulesMetadataStart = modulesEnd;

  const possibleChunkSizes = [120, 80, 56, 48, 40, 36, 32, 28, 24, 18, 12];
  const modulesMetadataChunkSize =
    possibleChunkSizes.find((sz) => modulesPtr.length % sz === 0) ??
    (() => {
      throw new InvalidExecutableError(
        `Unknown modules metadata layout (length=${modulesPtr.length}).`,
      );
    })();

  const bundledFiles: BundledFile[] = [];

  for (let i = 0; i <= modulesPtr.length / modulesMetadataChunkSize; i++) {

     const base = modulesMetadataStart + i * modulesMetadataChunkSize;

    const namePtr = readPtr(base + 0);
    const contentsPtr = readPtr(base + 8);
    const sourcemapPtr = readPtr(base + 16);

    // Skip internal/auxiliary entries (no name)
    if (namePtr.length === 0) {
      continue;
    }

    const isEntrypoint = i === entrypointId;

    let path = decoder.decode(
      modulesData.slice(namePtr.offset, namePtr.offset + namePtr.length),
    );

    // Optional: extra guard â€“ Bun sometimes stores helper modules without the bunfs root.
    if (!path.includes(BUNFS_ROOT) && !path.includes(BUNFS_ROOT_OLD)) {
      continue;
    }

    if (options.normaliseEntrypointFileName && isEntrypoint) {
      path = path.replace(/\/[^\/\\]+$/, "/index.js");
    }

    try {
      path = removeBunfsRootFromPath(path);
    } catch (e) {
      console.log(e, path)
      continue;
    }
 
    if (path[0] !== "/") {
      throw new InvalidExecutableError("Invalid path in bundled file in executable");
    }
    path = removeLeadingSlash(path);

    // Read contents using its recorded offset/length (binary-safe).
    const contents = modulesData.slice(
      contentsPtr.offset,
      contentsPtr.offset + contentsPtr.length,
    );

    let sourcemap: BundledFile["sourcemap"];
    if (sourcemapPtr.length) {
      // SerializedSourceMap layout:
      // header (8 bytes: u32 source_files_count, u32 map_bytes_length)
      // + source_files_count * StringPointer (names)
      // + source_files_count * StringPointer (compressed contents)
      // + map_bytes_length bytes (VLQ mappings)
      const smHeaderOff = modulesStart + sourcemapPtr.offset;
      const sourcesCount = compiledBinaryData.getUint32(smHeaderOff + 0, true);
      const mapBytesLength = compiledBinaryData.getUint32(smHeaderOff + 4, true);

      if (mapBytesLength) {
        const mappingsStart = sourcemapPtr.offset + 8 + sourcesCount * 16;
        const mappingsEnd = mappingsStart + mapBytesLength;

        // Extract optional debugId from the tail of the JS/TS contents, if present.
        const tail = contents.slice(
          Math.max(0, (contents as ArrayBuffer).byteLength - 49),
        );
        const debugId = decoder
          .decode(tail)
          .match(/^\/\/# debugId=([a-fA-F0-9-]{12,})$/m)?.[1];

        sourcemap = {
          version: 3,
          file: path,
          debugId,
          mappings: decoder.decode(modulesData.slice(mappingsStart, mappingsEnd)),
          sources: [],
        };

        // Read source file names via their StringPointer array
        for (let j = 0; j < sourcesCount; j++) {
          const ptrBase = smHeaderOff + 8 + j * 8; // first names pointer table
          const srcNameOffset = compiledBinaryData.getUint32(ptrBase + 0, true);
          const srcNameLength = compiledBinaryData.getUint32(ptrBase + 4, true);
          sourcemap.sources.push(
            decoder.decode(
              modulesData.slice(srcNameOffset, srcNameOffset + srcNameLength),
            ),
          );
        }
      }
    }

    const bundledFile: BundledFile = { path, contents, sourcemap };
    if (isEntrypoint) {
      bundledFiles.unshift(bundledFile);
    } else {
      bundledFiles.push(bundledFile);
    }
  }

  return bundledFiles;
}


function getModulesStart(compiledBinaryData: DataView) {
  if (compiledBinaryData.byteLength <= 48) {
    return 0;
  }

  const offsetByteCount = compiledBinaryData.getUint32(compiledBinaryData.byteLength - 48, true);

  return compiledBinaryData.byteLength - (offsetByteCount + 48);
}

function removeBunfsRootFromPath(path: string) {
  if (path.startsWith(BUNFS_ROOT)) {
    return path.slice(BUNFS_ROOT.length);
  }
  if (path.startsWith(BUNFS_ROOT_OLD)) {
    return path.slice(BUNFS_ROOT_OLD.length);
  }
  throw new Error(`Path does not start with Bun-fs root: ${path}`);
}

export function removeLeadingSlash(path: string) {
  return path.replace(/^\/?(?:\.\/)?/, "");
}

export interface BunVersion {
  version: string;
  revision: string;
  newFormat?: boolean;
}

function getExecutableVersionNew(data: Uint8Array, modulesStart: number): BunVersion {
  const versionIndex = data.findIndex((_, index) => {
    if (index >= modulesStart) {
      return false;
    }

    for (let i = 0; i < BUN_VERSION_MATCH.length; i++) {
      if (data[index + i] !== BUN_VERSION_MATCH.charCodeAt(i)) {
        return false;
      }
    }

    return true;
  });

  if (versionIndex === -1) {
    throw new VersionNotFoundError();
  }

  const versionEndIndex = data.indexOf(27, versionIndex + BUN_VERSION_MATCH.length);

  if (versionEndIndex <= 0) {
    throw new VersionNotFoundError();
  }

  const decoder = new TextDecoder();
  const versionString = decoder.decode(
    data.slice(versionIndex + BUN_VERSION_MATCH.length, versionEndIndex),
  );

  const [, version, revision] = versionString.match(/^(.+) \((.+)\)$/) ?? [];

  if (!version) {
    throw new VersionNotFoundError();
  }

  return {
    version,
    revision,
  };
}

function getExecutableVersionOld(data: Uint8Array, modulesStart: number): BunVersion {
  const versionIndex = data.findIndex((_, index) => {
    if (index >= modulesStart) {
      return false;
    }

    for (let i = 0; i < BUN_VERSION_MATCH_OLD.length; i++) {
      if (data[index + i] !== BUN_VERSION_MATCH_OLD.charCodeAt(i)) {
        return false;
      }
    }

    return true;
  });

  if (versionIndex === -1) {
    throw new VersionNotFoundError();
  }

  const versionEndIndex = data.indexOf(58, versionIndex + BUN_VERSION_MATCH_OLD.length);

  if (versionEndIndex <= 0) {
    throw new VersionNotFoundError();
  }

  const decoder = new TextDecoder();
  const versionString = decoder.decode(
    data.slice(versionIndex + BUN_VERSION_MATCH_OLD.length, versionEndIndex),
  );

  const [, version, revision] = versionString.match(/^(.+) \((.+)\)/) ?? [];

  if (!version) {
    throw new VersionNotFoundError();
  }

  return {
    version,
    revision,
  };
}

export function getExecutableVersion(data: Uint8Array | ArrayBuffer): BunVersion {
  if (data instanceof ArrayBuffer) {
    data = new Uint8Array(data);
  }

  const modulesStart = getModulesStart(new DataView(data.buffer));

  try {
    return { ...getExecutableVersionNew(data, modulesStart), newFormat: true };
  } catch (e) {
    if (e instanceof VersionNotFoundError) {
      return { ...getExecutableVersionOld(data, modulesStart), newFormat: false };
    }

    throw e;
  }
}
